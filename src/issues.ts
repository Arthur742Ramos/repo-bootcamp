/**
 * Auto-Issue Creator Module
 * Creates GitHub issues from FIRST_TASKS using the gh CLI
 */

import { execFile } from "child_process";
import { promisify } from "util";
import chalk from "chalk";
import type { FirstTask, RepoInfo } from "./types.js";

const execFileAsync = promisify(execFile);

/**
 * Issue to be created
 */
export interface IssuePayload {
  title: string;
  body: string;
  labels: string[];
}

/**
 * Result of issue creation
 */
export interface IssueResult {
  success: boolean;
  url?: string;
  error?: string;
  payload: IssuePayload;
}

/**
 * Check if gh CLI is available and authenticated
 */
export async function checkGhAuth(): Promise<{ available: boolean; authenticated: boolean; error?: string }> {
  try {
    await execFileAsync("which", ["gh"]);
  } catch {
    return { available: false, authenticated: false, error: "gh CLI not installed" };
  }

  try {
    await execFileAsync("gh", ["auth", "status"]);
    return { available: true, authenticated: true };
  } catch (error: unknown) {
    return { 
      available: true, 
      authenticated: false, 
      error: "gh CLI not authenticated. Run 'gh auth login' first." 
    };
  }
}

/**
 * Map difficulty to label
 */
function difficultyToLabel(difficulty: FirstTask["difficulty"]): string {
  switch (difficulty) {
    case "beginner": return "good first issue";
    case "intermediate": return "help wanted";
    case "advanced": return "enhancement";
  }
}

/**
 * Map category to label
 */
function categoryToLabel(category: FirstTask["category"]): string {
  switch (category) {
    case "bug-fix": return "bug";
    case "test": return "testing";
    case "docs": return "documentation";
    case "refactor": return "refactor";
    case "feature": return "enhancement";
  }
}

/**
 * Convert a FirstTask to an issue payload
 */
export function taskToIssuePayload(task: FirstTask, repoInfo: RepoInfo): IssuePayload {
  const body = `## Description

${task.description}

## Why This Task?

${task.why}

## Difficulty

**${task.difficulty.charAt(0).toUpperCase() + task.difficulty.slice(1)}** - ${
    task.difficulty === "beginner" ? "Great for newcomers!" :
    task.difficulty === "intermediate" ? "Some familiarity with the codebase helpful." :
    "Requires deep understanding of the codebase."
  }

## Files to Look At

${task.files.map(f => `- \`${f}\``).join("\n")}

---

*This issue was auto-generated by [Repo Bootcamp](https://github.com/${repoInfo.fullName}).*
`;

  return {
    title: task.title,
    body,
    labels: [
      difficultyToLabel(task.difficulty),
      categoryToLabel(task.category),
    ],
  };
}

/**
 * Create a single GitHub issue
 */
async function createIssue(
  payload: IssuePayload,
  repoInfo: RepoInfo
): Promise<IssueResult> {
  try {
    // Build arguments array (safe from shell injection)
    const args = [
      "issue", "create",
      "--repo", repoInfo.fullName,
      "--title", payload.title,
      "--body", payload.body,
    ];
    
    // Add labels
    for (const label of payload.labels) {
      args.push("--label", label);
    }

    const { stdout } = await execFileAsync("gh", args, { timeout: 30000 });
    const url = stdout.trim();

    return {
      success: true,
      url,
      payload,
    };
  } catch (error: unknown) {
    return {
      success: false,
      error: (error as Error).message,
      payload,
    };
  }
}

/**
 * Create issues for all first tasks
 */
export async function createIssuesFromTasks(
  tasks: FirstTask[],
  repoInfo: RepoInfo,
  options: { dryRun?: boolean; verbose?: boolean } = {}
): Promise<IssueResult[]> {
  const results: IssueResult[] = [];

  // Check gh CLI availability
  if (!options.dryRun) {
    const auth = await checkGhAuth();
    if (!auth.available) {
      console.error(chalk.red("Error: gh CLI not found. Please install it from https://cli.github.com"));
      throw new Error("gh CLI not available");
    }
    if (!auth.authenticated) {
      console.error(chalk.red("Error: gh CLI not authenticated. Run 'gh auth login' first."));
      throw new Error("gh CLI not authenticated");
    }
  }

  console.log(chalk.cyan(`\n${options.dryRun ? "[DRY RUN] " : ""}Creating ${tasks.length} issues...\n`));

  for (let i = 0; i < tasks.length; i++) {
    const task = tasks[i];
    const payload = taskToIssuePayload(task, repoInfo);

    console.log(chalk.white(`[${i + 1}/${tasks.length}] ${payload.title}`));
    console.log(chalk.gray(`  Labels: ${payload.labels.join(", ")}`));

    if (options.dryRun) {
      // Just show preview
      if (options.verbose) {
        console.log(chalk.gray(`  Body preview: ${payload.body.substring(0, 100)}...`));
      }
      results.push({
        success: true,
        payload,
      });
      console.log(chalk.yellow("  [DRY RUN] Would create issue"));
    } else {
      const result = await createIssue(payload, repoInfo);
      results.push(result);

      if (result.success) {
        console.log(chalk.green(`  Created: ${result.url}`));
      } else {
        console.log(chalk.red(`  Failed: ${result.error}`));
      }

      // Small delay to avoid rate limiting
      await new Promise(r => setTimeout(r, 500));
    }
  }

  // Summary
  const successful = results.filter(r => r.success).length;
  const failed = results.filter(r => !r.success).length;

  console.log();
  if (options.dryRun) {
    console.log(chalk.yellow(`[DRY RUN] Would create ${successful} issues`));
    console.log(chalk.gray("Run without --dry-run to actually create issues."));
  } else {
    console.log(chalk.green(`Created: ${successful} issues`));
    if (failed > 0) {
      console.log(chalk.red(`Failed: ${failed} issues`));
    }
  }

  return results;
}

/**
 * Generate preview markdown for issues
 */
export function generateIssuePreview(tasks: FirstTask[], repoInfo: RepoInfo): string {
  const lines: string[] = [];

  lines.push("# Issue Preview");
  lines.push("");
  lines.push(`The following ${tasks.length} issues would be created in **${repoInfo.fullName}**:`);
  lines.push("");

  for (let i = 0; i < tasks.length; i++) {
    const task = tasks[i];
    const payload = taskToIssuePayload(task, repoInfo);

    lines.push(`## ${i + 1}. ${payload.title}`);
    lines.push("");
    lines.push(`**Labels:** ${payload.labels.join(", ")}`);
    lines.push("");
    lines.push("<details>");
    lines.push("<summary>Issue Body</summary>");
    lines.push("");
    lines.push(payload.body);
    lines.push("");
    lines.push("</details>");
    lines.push("");
    lines.push("---");
    lines.push("");
  }

  lines.push("## Commands");
  lines.push("");
  lines.push("To create these issues, run:");
  lines.push("```bash");
  lines.push("bootcamp <repo-url> --create-issues");
  lines.push("```");
  lines.push("");
  lines.push("To preview without creating:");
  lines.push("```bash");
  lines.push("bootcamp <repo-url> --create-issues --dry-run");
  lines.push("```");

  return lines.join("\n");
}
